import chalk from "chalk";
import EventEmitter from "events";
import { Router, Request, Response } from "express";
import { readdir, stat } from "fs/promises";
import { platform } from "os";
import { join } from "path";
import { instance, settingsManager } from ".";
import * as pty from "node-pty";
import { writeFileSync } from "fs";
import { cwd } from "process";
import { spawnSync } from "child_process";

class McServer extends EventEmitter {
	status: serverStatus;
	worldSize!: WorldSize;
	process!: pty.IPty;

	constructor(autostart = false) {
		super();
		this.status = { enabled: false, isStarting: false, isStopping: false, players: [], startDate: null };

		// Create the starter file
		const JRE_FLAGS = process.env.JRE_FLAGS || "";
		if (platform() === "win32") {
			//Yes it has to be indented like this
			writeFileSync(
				join(cwd(), "cache", "starter.bat"),
				`:: THIS FILE IS AUTOMATICALY GENERATED BY CONZEFORD
:: DO NOT EDIT THIS FILE
@echo off
cls
java ${JRE_FLAGS} -jar ${join(process.env.SERVER_DIR as string, process.env.SERVER_JAR as string)} --nogui`
			);
		} else if (platform() === "linux") {
			//Yes it has to be indented like this
			writeFileSync(
				join(cwd(), "cache", "starter.sh"),
				`# THIS FILE IS AUTOMATICALY GENERATED BY CONZEFORD
# DO NOT EDIT THIS FILE
clear
java ${JRE_FLAGS} -jar ${join(process.env.SERVER_DIR as string, process.env.SERVER_JAR as string)} --nogui`
			);

			spawnSync("chmod", ["+x", join(cwd(), "cache", "starter.sh")]);
		} else {
			console.error(chalk.red("Unsupported platform"));
			process.exitCode = 1;
		}

		if (autostart) {
			setTimeout(() => {
				this.start();
			}, 5000);
		}
	}

	stop = (immediate = false) => {
		const shutdownDelay = settingsManager.settings.shutdownDelay;
		if (this.status.enabled && !this.status.isStopping) {
			if (shutdownDelay.enabled && !immediate) {
				this.process.write(`say ${shutdownDelay.message.replace("{delay}", shutdownDelay.delay.toString())}\n`);

				setTimeout(() => {
					this.process.write("stop\n");
					this.status.isStopping = true;
					this.status.startDate = null;
					this.emit("status", this.status);
				}, shutdownDelay.delay * 1000);
			} else {
				this.process.write("stop\n");
				this.status.isStopping = true;
				this.status.startDate = null;
				this.emit("status", this.status);
			}
			return true;
		}
		return false;
	};

	start = async () => {
		if (!this.status.enabled && !this.status.isStarting) {
			this.process = pty.spawn(join(cwd(), "cache", `starter.${platform() == "win32" ? "bat" : "sh"}`), [], {
				name: "conzefordTTY",
				cols: 120,
				rows: 60,
				cwd: process.env.SERVER_DIR
			});

			this.status.isStarting = true;
			this.emit("status", this.status);

			//Wait for the shell to start
			this.process.on("data", (data) => {
				this.emit("stdout", data);

				if (this.status.isStarting) {
					if (data.match(/(Done \(\d*\.\d{3}s\)! For help, type "help")/)) {
						this.status.enabled = true;
						this.status.isStarting = false;
						this.emit("status", this.status);
					}
				}

				if (this.status.enabled) {
					if (data.match(/\[INFO\] Stopping server/)) {
						this.status.isStopping = true;
						this.emit("status", this.status);
					}

					//I know this can be easly spoofed for example with modified chat messages
					//and I will probably use a plugin to do this
					//but it's enough for now
					if (data.match(/(?:(\w*) joined the game)/) && !data.match(/<\w*>/)) {
						const player = data.match(/(?:(\w*) joined the game)/) as RegExpMatchArray;
						this.status.players.push(player[1]);
						this.emit("status", this.status);
					} else if (data.match(/(?:(\w*) left the game)/) && !data.match(/<\w*>/)) {
						const player = data.match(/((?<player>\w*) left the game)/) as RegExpMatchArray;
						this.status.players.splice(this.status.players.indexOf(player[1]), 1);
						this.emit("status", this.status);
					}
				}
			});

			this.process.on("exit", (code) => {
				this.status.enabled = false;
				this.status.isStarting = false;
				this.status.isStopping = false;
				this.status.startDate = null;
				this.status.players = [];
				if (code != 0) this.emit("crash", "The server has crashed. Checkout the crash logs.");

				this.emit("status", this.status);
			});

			// 	this.process.on("error", async (error: any) => {
			// 		if (error.code == "ENOENT") {
			// 			console.log(chalk.red(new Error("SERVER_DIR/SERVER_JAR is not a valid path.")));
			// 			await createCrashLog(
			// 				`SERVER_DIR/SERVER_JAR is not a valid path.\n Your path: ${join(
			// 					process.env.SERVER_DIR as string,
			// 					process.env.SERVER_JAR as string
			// 				)}`
			// 			);
			// 		} else {
			// 			console.log(chalk.red(new Error("Unexpected error occured when starting the server.")));
			// 			await createCrashLog(`Unexpected error while staring the server:\n${error.toString()}`);
			// 		}

			// 		this.emit("crash", "There was an error while starting the server.");
			// 	});

			this.status.startDate = new Date();
			return true;
		}

		return false;
	};

	restart = (immediate = false) => {
		if (this.status.enabled && !this.status.isStarting && !this.status.isStopping) {
			this.stop(immediate);

			const onIdle = async () => {
				if (!this.status.enabled && !this.status.isStarting && !this.status.isStopping) {
					await this.start();
					instance.off("status", onIdle);
				}
			};

			instance.on("status", onIdle);
		}
	};

	executeCommand = (command: string) => {
		if (this.status.enabled && !this.status.isStopping && !this.status.isStarting) {
			this.emit("stdout", Buffer.from(`> ${command}\n`));
			this.process.write(`${command}\n`);
		}
	};

	getWorldSize = async (refresh = false) => {
		if (this.worldSize != undefined && this.worldSize.worlds.length > 0 && !refresh) return this.worldSize;

		const worldSize: WorldSize = { worlds: [], date: new Date().getTime() };

		const readSizeRecursive = (path: string, exlude: string[] = []): Promise<TreeFolder> => {
			return new Promise((resolve, reject) => {
				const name = path.split("\\");
				const tree: TreeFolder = { dirs: [], files: [], name: name[name.length - 1], size: 0 };

				readdir(path)
					.then(async (dirs) => {
						for (const dir of dirs) {
							if (exlude.includes(dir)) continue;

							const fullDir = join(path, dir);
							const dirStat = await stat(fullDir);

							if (dirStat.isDirectory()) {
								//If is a folder scan it recursively
								tree.dirs.push(await readSizeRecursive(fullDir));
							} else if (dirStat.isFile()) {
								tree.files.push(dirStat.size);
							}
						}

						tree.size = sumBytes(tree);

						resolve(tree);
					})
					.catch((e) => reject(e));
			});
		};

		const sumBytes = (tree: TreeFolder) => {
			//Sum up all the Bytes in folders and files
			let bytesSum = 0;

			for (const dir of tree.dirs) {
				bytesSum += dir.size;
			}

			bytesSum += tree.files.reduce((a, b) => a + b, 0);

			return bytesSum;
		};

		try {
			const worldProbe = await readdir(join(process.env.SERVER_DIR as string, "world"));

			if (worldProbe.includes("DIM1")) {
				const world = await readSizeRecursive(join(process.env.SERVER_DIR as string, "world"));
				worldSize.worlds.push({ name: "world", size: world.size });

				const nether = await readSizeRecursive(join(process.env.SERVER_DIR as string, "world", "DIM-1"));
				worldSize.worlds.push({ name: "world_nether", size: nether.size });

				const end = await readSizeRecursive(join(process.env.SERVER_DIR as string, "world", "DIM1"));
				worldSize.worlds.push({ name: "world_the_end", size: end.size });
			} else {
				const dir = await readdir(join(process.env.SERVER_DIR as string));

				for (const folder of dir) {
					if (["world", "world_nether", "world_the_end"].includes(folder)) {
						const world = await readSizeRecursive(join(process.env.SERVER_DIR as string, folder));
						worldSize.worlds.push({ name: world.name, size: world.size });
					}
				}
			}
		} catch (error) {
			console.log(chalk.red(new Error("Unexpected error occured when getting the world size.")));
			return undefined;
		}

		this.worldSize = worldSize;
		return worldSize;
	};
}

// const createCrashLog = async (error: string) => {
// 	const logs = await readdir(join(process.cwd(), "logs"));

// 	let crashLogNumber = 1;

// 	for (const log of logs) {
// 		if (log.includes(new Date().toLocaleDateString())) {
// 			crashLogNumber++;
// 		}
// 	}

// 	const fileName = `crashLog-${new Date().toLocaleDateString()}-${crashLogNumber}.txt`;

// 	await writeFile(join(process.cwd(), "logs", fileName), error);
// };

export const serverRouter = Router();

serverRouter.get("/worldSize", async (req: Request, res: Response) => {
	const worldSize = await instance.getWorldSize(req.query.refresh == "true");
	res.status(200).json(worldSize);
});

export default McServer;
